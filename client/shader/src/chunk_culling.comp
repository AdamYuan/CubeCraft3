#version 450
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

struct AABB {
	float min_x, min_y, min_z, max_x, max_y, max_z;
};
struct MeshInfo {
	uint index_count, first_index, vertex_offset;
	AABB aabb;
	int base_pos_x, base_pos_y, base_pos_z;
};
struct DrawIndexedIndirectCommand {
	uint index_count, instance_count, first_index, vertex_offset, first_instance;
};

layout(set = 0, binding = 0) uniform uuCamera { mat4 uViewProjection; };

layout(std430, set = 1, binding = 0) readonly buffer uuMeshInfo { MeshInfo uMeshInfo[]; };
layout(std430, set = 1, binding = 1) writeonly buffer uuDrawCommand { DrawIndexedIndirectCommand uDrawCommand[]; };
layout(std430, set = 1, binding = 2) buffer uuDrawCount { uint uDrawCount; };

layout(push_constant) uniform uuPushConstant { vec4 uFrustum[5]; };

bool FrustumCull(in const AABB aabb) {
	vec3 axis;
	axis.x = uFrustum[0].x < 0.0 ? aabb.min_x : aabb.max_x;
	axis.y = uFrustum[0].y < 0.0 ? aabb.min_y : aabb.max_y;
	axis.z = uFrustum[0].z < 0.0 ? aabb.min_z : aabb.max_z;
	if (dot(uFrustum[0].xyz, axis) + uFrustum[0].w < 0.0)
		return true;
	axis.x = uFrustum[1].x < 0.0 ? aabb.min_x : aabb.max_x;
	axis.y = uFrustum[1].y < 0.0 ? aabb.min_y : aabb.max_y;
	axis.z = uFrustum[1].z < 0.0 ? aabb.min_z : aabb.max_z;
	if (dot(uFrustum[1].xyz, axis) + uFrustum[1].w < 0.0)
		return true;
	axis.x = uFrustum[2].x < 0.0 ? aabb.min_x : aabb.max_x;
	axis.y = uFrustum[2].y < 0.0 ? aabb.min_y : aabb.max_y;
	axis.z = uFrustum[2].z < 0.0 ? aabb.min_z : aabb.max_z;
	if (dot(uFrustum[2].xyz, axis) + uFrustum[2].w < 0.0)
		return true;
	axis.x = uFrustum[3].x < 0.0 ? aabb.min_x : aabb.max_x;
	axis.y = uFrustum[3].y < 0.0 ? aabb.min_y : aabb.max_y;
	axis.z = uFrustum[3].z < 0.0 ? aabb.min_z : aabb.max_z;
	if (dot(uFrustum[3].xyz, axis) + uFrustum[3].w < 0.0)
		return true;
	axis.x = uFrustum[4].x < 0.0 ? aabb.min_x : aabb.max_x;
	axis.y = uFrustum[4].y < 0.0 ? aabb.min_y : aabb.max_y;
	axis.z = uFrustum[4].z < 0.0 ? aabb.min_z : aabb.max_z;
	if (dot(uFrustum[4].xyz, axis) + uFrustum[4].w < 0.0)
		return true;
	// ignore far plane culling
	/* axis.x = uFrustum[5].x < 0.0 ? aabb.min_x : aabb.max_x;
	axis.y = uFrustum[5].y < 0.0 ? aabb.min_y : aabb.max_y;
	axis.z = uFrustum[5].z < 0.0 ? aabb.min_z : aabb.max_z;
	if (dot(uFrustum[5].xyz, axis) + uFrustum[5].w < 0.0)
	    return true; */
	return false;
}

void GetScreenAABB(in const AABB aabb, out vec3 screen_min, out vec3 screen_max) {
	vec3 x = (uViewProjection * vec4(aabb.min_x, aabb.min_y, aabb.min_z, 1.0)).xyz;
	vec3 y = (uViewProjection * vec4(aabb.max_x, aabb.max_y, aabb.max_z, 1.0)).xyz;
	screen_min = min(x, y);
	screen_max = max(x, y);
}

void main() {
	uint mesh_id = gl_GlobalInvocationID.x;
	if (mesh_id >= uMeshInfo.length())
		return;
	AABB aabb = uMeshInfo[mesh_id].aabb;
	if (FrustumCull(aabb))
		return;
	uint draw_id = atomicAdd(uDrawCount, 1u);
	uDrawCommand[draw_id] = DrawIndexedIndirectCommand(
	    uMeshInfo[mesh_id].index_count, 1, uMeshInfo[mesh_id].first_index, uMeshInfo[mesh_id].vertex_offset, mesh_id);
}
